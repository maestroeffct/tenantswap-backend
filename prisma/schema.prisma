generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                         String             @id @default(uuid())
  role                       UserRole           @default(USER)
  fullName                   String
  email                      String?            @unique
  phone                      String             @unique
  password                   String
  emailVerifiedAt            DateTime?
  emailVerificationTokenHash String?
  emailVerificationExpiresAt DateTime?
  subscriptionStatus         SubscriptionStatus @default(INACTIVE)
  subscriptionPlan           String?
  subscriptionProvider       String?
  subscriptionReference      String?
  subscriptionStartedAt      DateTime?
  subscriptionExpiresAt      DateTime?
  reliabilityScore           Int                @default(100)
  cancellationCount          Int                @default(0)
  noShowCount                Int                @default(0)
  cooldownUntil              DateTime?
  blockedUntil               DateTime?
  createdAt                  DateTime           @default(now())

  listings            SwapListing[]
  notifications       UserNotification[]
  interestsRequested  ListingInterest[]    @relation("UserRequestedInterests")
  paymentTransactions PaymentTransaction[]
  reliabilityEvents   ReliabilityEvent[]

  @@index([emailVerificationTokenHash])
  @@index([subscriptionStatus, subscriptionExpiresAt])
  @@index([blockedUntil, cooldownUntil])
}

model SwapListing {
  id     String        @id @default(uuid())
  userId String
  status ListingStatus @default(DRAFT)

  // WHAT USER IS LOOKING FOR
  desiredType String
  desiredCity String
  maxBudget   Int
  timeline    String

  // WHAT USER IS LEAVING
  currentType String
  currentCity String
  currentRent Int
  availableOn DateTime

  features String[]

  // Interest-based matching metadata.
  matchedInterestId String?
  matchedAt         DateTime?
  expiresAt         DateTime?
  closedAt          DateTime?
  closeReason       ListingCloseReason?
  closedByUserId    String?

  createdAt DateTime @default(now())

  user              User              @relation(fields: [userId], references: [id])
  incomingInterests ListingInterest[] @relation("ListingIncomingInterests")
  outgoingInterests ListingInterest[] @relation("ListingOutgoingInterests")

  @@index([matchedInterestId])
  @@index([status, expiresAt])
}

enum UserRole {
  USER
  ADMIN
}

enum ListingStatus {
  DRAFT
  ACTIVE
  MATCHED
  CLOSED
}

enum ListingCloseReason {
  MATCH_CONFIRMED
  REQUESTER_CONFIRMED
  OWNER_CLOSED
  EXPIRED
  ADMIN_CLOSED
}

enum SubscriptionStatus {
  INACTIVE
  ACTIVE
  PAST_DUE
  CANCELED
  EXPIRED
}

enum ChainStatus {
  PENDING
  LOCKED
  BROKEN
}

enum ChainType {
  DIRECT
  CIRCULAR
}

enum ChainBreakReason {
  DECLINED
  EXPIRED
  ADMIN_FORCE
  NO_SHOW
  CONFLICT
  UNKNOWN
}

enum ListingInterestStatus {
  REQUESTED
  CONTACT_APPROVED
  DECLINED
  RELEASED
  EXPIRED
  CONFIRMED_RENTER
}

enum InterestConfirmedBy {
  LISTER
  WANTER
  ADMIN
}

enum ReliabilityEventType {
  CANCELLATION
  NO_SHOW
  MANUAL_PENALTY
  MANUAL_UNBLOCK
}

model MatchCandidate {
  id String @id @default(uuid())

  fromListingId String
  toListingId   String

  cityScore     Int
  typeScore     Int
  budgetScore   Int
  timelineScore Int
  totalScore    Int

  createdAt DateTime @default(now())

  @@unique([fromListingId, toListingId])
}

model ListingInterest {
  id                 String                @id @default(uuid())
  listingId          String
  requesterListingId String
  requesterUserId    String
  status             ListingInterestStatus @default(REQUESTED)
  expiresAt          DateTime?
  respondedAt        DateTime?
  releasedAt         DateTime?
  confirmedAt        DateTime?
  confirmedByUserId  String?
  confirmedByRole    InterestConfirmedBy?
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt

  listing          SwapListing @relation("ListingIncomingInterests", fields: [listingId], references: [id])
  requesterListing SwapListing @relation("ListingOutgoingInterests", fields: [requesterListingId], references: [id])
  requesterUser    User        @relation("UserRequestedInterests", fields: [requesterUserId], references: [id])

  @@unique([listingId, requesterListingId])
  @@index([listingId, status, createdAt])
  @@index([requesterUserId, status, createdAt])
  @@index([status, expiresAt])
  @@index([status, confirmedAt])
}

model SwapChain {
  id     String      @id @default(uuid())
  status ChainStatus @default(PENDING)
  type   ChainType   @default(CIRCULAR)

  cycleSize Int
  avgScore  Int

  // Chain acceptance deadline.
  acceptBy DateTime?

  // Break metadata helps post-mortem and enforcement rules.
  brokenReason   ChainBreakReason?
  brokenAt       DateTime?
  brokenByUserId String?

  // prevents mirrored duplicates
  cycleHash String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members        SwapChainMember[]
  contactUnlocks ContactUnlock[]

  @@index([status, acceptBy])
}

model SwapChainMember {
  id        String @id @default(uuid())
  chainId   String
  listingId String
  userId    String
  position  Int

  hasAccepted Boolean @default(false)

  chain SwapChain @relation(fields: [chainId], references: [id])

  @@unique([chainId, listingId])
  @@index([userId])
}

model ContactUnlock {
  id              String   @id @default(uuid())
  chainId         String
  requesterUserId String
  createdAt       DateTime @default(now())

  approvals ContactUnlockApproval[]

  chain SwapChain @relation(fields: [chainId], references: [id])

  @@index([chainId])
}

model ContactUnlockApproval {
  id              String   @id @default(uuid())
  contactUnlockId String
  approverUserId  String
  approved        Boolean  @default(true)
  createdAt       DateTime @default(now())

  contactUnlock ContactUnlock @relation(fields: [contactUnlockId], references: [id])

  @@unique([contactUnlockId, approverUserId])
}

model ReliabilityEvent {
  id            String               @id @default(uuid())
  userId        String
  actorUserId   String?
  eventType     ReliabilityEventType
  scoreDelta    Int                  @default(0)
  reason        String?
  metadata      Json?
  cooldownUntil DateTime?
  blockedUntil  DateTime?
  createdAt     DateTime             @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([eventType, createdAt])
}

model PaymentTransaction {
  id                  String                   @id @default(uuid())
  userId              String
  provider            String
  providerEventId     String?
  providerReference   String                   @unique
  amountMinor         Int
  currency            String                   @default("NGN")
  planCode            String?
  status              PaymentTransactionStatus @default(PENDING)
  paidAt              DateTime?
  subscriptionStartAt DateTime?
  subscriptionEndAt   DateTime?
  metadata            Json?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([status, createdAt])
}

enum PaymentTransactionStatus {
  PENDING
  SUCCESS
  FAILED
  CANCELED
}

model PaymentWebhookEvent {
  id          String   @id @default(uuid())
  provider    String
  eventId     String
  eventType   String
  signature   String?
  payload     Json
  processedAt DateTime @default(now())
  createdAt   DateTime @default(now())

  @@unique([provider, eventId])
  @@index([provider, eventType, createdAt])
}

model UserNotification {
  id        String    @id @default(uuid())
  userId    String
  chainId   String?
  type      String
  title     String
  message   String
  payload   Json?
  readAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([chainId])
}

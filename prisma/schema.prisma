generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                         String    @id @default(uuid())
  role                       UserRole  @default(USER)
  fullName                   String
  email                      String?   @unique
  phone                      String    @unique
  password                   String
  emailVerifiedAt            DateTime?
  emailVerificationTokenHash String?
  emailVerificationExpiresAt DateTime?
  createdAt                  DateTime  @default(now())

  listings      SwapListing[]
  notifications UserNotification[]

  @@index([emailVerificationTokenHash])
}

model SwapListing {
  id     String        @id @default(uuid())
  userId String
  status ListingStatus @default(DRAFT)

  // WHAT USER IS LOOKING FOR
  desiredType String
  desiredCity String
  maxBudget   Int
  timeline    String

  // WHAT USER IS LEAVING
  currentType String
  currentCity String
  currentRent Int
  availableOn DateTime

  features  String[]
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

enum UserRole {
  USER
  ADMIN
}

enum ListingStatus {
  DRAFT
  ACTIVE
  MATCHED
  CLOSED
}

enum ChainStatus {
  PENDING
  LOCKED
  BROKEN
}

enum ChainType {
  DIRECT
  CIRCULAR
}

enum ChainBreakReason {
  DECLINED
  EXPIRED
  ADMIN_FORCE
  NO_SHOW
  CONFLICT
  UNKNOWN
}

model MatchCandidate {
  id String @id @default(uuid())

  fromListingId String
  toListingId   String

  cityScore     Int
  typeScore     Int
  budgetScore   Int
  timelineScore Int
  totalScore    Int

  createdAt DateTime @default(now())

  @@unique([fromListingId, toListingId])
}

model SwapChain {
  id     String      @id @default(uuid())
  status ChainStatus @default(PENDING)
  type   ChainType   @default(CIRCULAR)

  cycleSize Int
  avgScore  Int

  // Chain acceptance deadline.
  acceptBy DateTime?

  // Break metadata helps post-mortem and enforcement rules.
  brokenReason   ChainBreakReason?
  brokenAt       DateTime?
  brokenByUserId String?

  // prevents mirrored duplicates
  cycleHash String @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members        SwapChainMember[]
  contactUnlocks ContactUnlock[]

  @@index([status, acceptBy])
}

model SwapChainMember {
  id        String @id @default(uuid())
  chainId   String
  listingId String
  userId    String
  position  Int

  hasAccepted Boolean @default(false)

  chain SwapChain @relation(fields: [chainId], references: [id])

  @@unique([chainId, listingId])
  @@index([userId])
}

model ContactUnlock {
  id              String   @id @default(uuid())
  chainId         String
  requesterUserId String
  createdAt       DateTime @default(now())

  approvals ContactUnlockApproval[]

  chain SwapChain @relation(fields: [chainId], references: [id])

  @@index([chainId])
}

model ContactUnlockApproval {
  id              String   @id @default(uuid())
  contactUnlockId String
  approverUserId  String
  approved        Boolean  @default(true)
  createdAt       DateTime @default(now())

  contactUnlock ContactUnlock @relation(fields: [contactUnlockId], references: [id])

  @@unique([contactUnlockId, approverUserId])
}

model UserNotification {
  id        String   @id @default(uuid())
  userId    String
  chainId   String?
  type      String
  title     String
  message   String
  payload   Json?
  readAt    DateTime?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([chainId])
}
